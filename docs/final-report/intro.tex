Large software systems have been growing rapidly and becoming more distributed. As a result, the traditional monolithic software architecture, where modules of different functionalities are closely coupled and developed by the same group of developers, is now challenged by a new architectural pattern: \textbf{Microservices}. A software system that employs microservice architecture comprises of a suite of clearly defined small services, each running in its own process \cite{lewis2014microservices}. As a result, each service can be developed by completely separated teams and using distinct technology stack, thereby decoupling the modules and parallelizing development.

In a monolithic system, all modules typically share the same backend database and enjoy the ACID (Atomicity, Consistency, Isolation, Durability) properties provided by the database \cite{gray1981transaction}. Under microservice architecture, however, each module would use a separate database to ensure good isolation among service modules, and each database might be using an entirely different technology. Therefore, large transactions that involves multiple modules, which used to run in the same database, now span across multiple databases with drastically different implementations. In this case, maintaining data consistency becomes a more complex task. \textbf{Two-phase-commit (2PC)} protocol \cite{bernstein1987concurrency} is a popular solution, where a coordinator process ensures all databases have the requested resource available before commiting the transaction. While 2PC ensures the correctness of distributed transactions, it requires all resources to be exclusively locked until the transaction finishes.

Unfortunately, in real world applications, many distributed transactions are long-lived, meaning they take much longer (in terms of hours and/or network gaps) to finish. For example, an e-commerce application may have ordering, billing, and shipping modules, and a complete transaction of purchasing an item would involve all components and would not complete until the item is shipped. In the case of these long-lived transactions, 2PC does not scale well because it locks all databases involved in the transaction and there can be many other transactions occurring in the system simultaneously.

Among the existing solutions to maintain data consistency in distributed databases of microservice systems, we chose to look at the \textbf{Saga pattern} \cite{garcia1987sagas}. There are a few arguments for Sagas over traditional consensus protocols such as 2PC. Firstly, the Saga pattern does not require synchronization of all databases in a transaction, making it more suitable for long-lived transactions. Also, Saga tends to be easier to implement than 2PC, whose logic is relatively complex.
