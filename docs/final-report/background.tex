A saga is a sequence of local transactions. Each local transaction updates the database and publishes an event to trigger the next local transaction in the saga \cite{richardson2014saga}. Using this pattern, a large distributed transaction is broken into multiple local transactions that update their local databases and publish events globally to notify others, which are then coordinated by a saga. To maintain data consistency, each local transaction theoretically must be accompanied by compensatory transaction. As a result, the saga can rollback the large transaction by executing these compensations in a reverse order.

In general, there are two types of sagas: \textit{choreography-based} and \textit{orchestration-based}. An orchestration-based saga is a standalone object that coordinates multiple service in a centralized manner, whereas choreography-based saga is implemented by each local transaction publishing domain events that trigger local transactions in other services \cite{richardson2014saga}.

The use of microservices and sagas also motivates the overall architectural pattern to deviate from the traditional layered architecture. \textbf{Event sourcing} and \textbf{Command Query Responsibility Segregation (CQRS)} are often used to fully implement sagas. Since sagas coordinate local transactions by publishing events after updating local datastores, it is vital for the publication and update to be atomic - otherwise the system ends up in an inconsistent state. Event sourcing is used to enforce atomicity of events publishing and datastore updates. Event sourcing persists the state of entity as a sequence of state changing events. Whenever an entity changes, a new event is appended. The final state of each entity must be consistent since adding a single event is atomic. Therefore, we donâ€™t need compensation rollback to maintain data consistency but persist events in an event store, adding or retrieving event when an entity is changed.

Unfortunately, with multiple local databases involved in one event store, querying these databases becomes much more difficult to implement than in a monolithic system. Since the current state of all entities are stored as a sequence of changing events rather than a static record, it is difficult to obtain the most up-to-date state of a certain entity. To mitigate the complexity, the CQRS architecture is often used in implementations of sagas. CQRS separates queries from commands/modifications to the datastore
