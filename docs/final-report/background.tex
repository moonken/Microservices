A saga is a sequence of local transactions. Each local transaction updates the database and publishes an event to trigger the next local transaction in the saga \cite{richardson2014saga}. Using this pattern, a large distributed transaction is broken into multiple local transactions that update their local databases and publish events globally to notify others, which are then coordinated by a saga. To maintain data consistency, each local transaction theoretically must be accompanied by compensatory transaction. As a result, the saga can rollback the large transaction by executing these compensations in a reverse order.

In general, there are two types of sagas: \textit{choreography-based} and \textit{orchestration-based}. An orchestration-based saga is a standalone object that coordinates multiple service in a centralized manner, whereas choreography-based saga is implemented by each local transaction publishing domain events that trigger local transactions in other services \cite{richardson2014saga}.

The use of microservices and sagas also motivates the overall architectural pattern to deviate from the traditional layered architecture. \textbf{Event sourcing} and \textbf{Command Query Responsibility Segregation (CQRS)} are often used to fully implement sagas. Since sagas coordinate local transactions by publishing events after updating local datastores, it is vital for the publication and update to be atomic - otherwise the system ends up in an inconsistent state. Event sourcing is used to enforce atomicity of events publishing and datastore updates.
